#![allow(non_upper_case_globals)]

pub struct TokenType;
impl TokenType {
    pub const Fn: i32 = 0;
    pub const IntegerValue: i32 = 1;
    pub const DecimalValue: i32 = 2;
    pub const CharValue: i32 = 3;
    pub const StringValue: i32 = 4;
    pub const i8: i32 = 5;
    pub const u8: i32 = 6;
    pub const i16: i32 = 7;
    pub const u16: i32 = 8;
    pub const Int: i32 = 9;
    pub const i32: i32 = 10;
    pub const u32: i32 = 11;
    pub const i64: i32 = 12;
    pub const u64: i32 = 13;
    pub const f32: i32 = 14;
    pub const f64: i32 = 15;
    pub const Usize: i32 = 16;
    pub const String: i32 = 17;
    pub const Bool: i32 = 18;
    pub const Char: i32 = 19;
    pub const Void: i32 = 20;
    pub const If: i32 = 21;
    pub const Else: i32 = 22;
    pub const For: i32 = 23;
    pub const While: i32 = 24;
    pub const Minus: i32 = 25;
    pub const Plus: i32 = 26;
    pub const PlusPlus: i32 = 27;
    pub const Divide: i32 = 28;
    pub const Multiply: i32 = 29;
    pub const Equals: i32 = 30;
    pub const Identifier: i32 = 31;
    pub const Return: i32 = 32;
    pub const Break: i32 = 33;
    pub const Continue: i32 = 34;
    pub const Print: i32 = 35;
    pub const Println: i32 = 36;
    pub const LeftParenthesis: i32 = 37;
    pub const RightParenthesis: i32 = 38;
    pub const LeftBrace: i32 = 39;
    pub const RightBrace: i32 = 40;
    pub const LeftSquareBracket: i32 = 41;
    pub const RightSquareBracket: i32 = 42;
    pub const Semicolon: i32 = 43;
    pub const True: i32 = 44;
    pub const False: i32 = 45;
    pub const Comment: i32 = 46;
    pub const EndComment: i32 = 47;
    pub const Comma: i32 = 48;
    pub const FullStop: i32 = 49;
    pub const PlusEquals: i32 = 50;
    pub const MinusEquals: i32 = 51;
    pub const MultiplyEquals: i32 = 52;
    pub const DivideEquals: i32 = 53;
    pub const GreaterThan: i32 = 54;
    pub const LessThan: i32 = 55;
    pub const EqualsEquals: i32 = 56;
    pub const GreaterThanEquals: i32 = 57;
    pub const LessThanEquals: i32 = 58;
    pub const VariableInSimpleForLoop: i32 = 59;
    pub const Defer: i32 = 60;
    pub const New: i32 = 61;
    pub const Delete: i32 = 62;
    pub const In: i32 = 63;
    pub const Const: i32 = 64;
    pub const Modulus: i32 = 65;
    pub const ModulusEquals: i32 = 66;
    pub const NotEquals: i32 = 67;
    pub const And: i32 = 68;
    pub const AndAnd: i32 = 69;
    pub const Or: i32 = 70;
    pub const OrOr: i32 = 71;
    pub const IntegerVarType: i32 = 72;
    pub const Na: i32 = 73;
}

pub fn token_type_to_string(token_type: i32) -> &'static str {
    match token_type {
        TokenType::Fn => return "Fn",
        TokenType::IntegerValue => return "IntegerValue",
        TokenType::DecimalValue => return "DecimalValue",
        TokenType::CharValue => return "CharValue",
        TokenType::StringValue => return "StringValue",
        TokenType::i8 => return "i8",
        TokenType::u8 => return "u8",
        TokenType::i16 => return "i16",
        TokenType::u16 => return "u16",
        TokenType::Int => return "Int",
        TokenType::i32 => return "i32",
        TokenType::u32 => return "u32",
        TokenType::i64 => return "i64",
        TokenType::u64 => return "u64",
        TokenType::f32 => return "f32",
        TokenType::f64 => return "f64",
        TokenType::Usize => return "Usize",
        TokenType::String => return "String",
        TokenType::Bool => return "Bool",
        TokenType::Char => return "Char",
        TokenType::Void => return "Void",
        TokenType::If => return "If",
        TokenType::Else => return "Else",
        TokenType::For => return "For",
        TokenType::While => return "While",
        TokenType::Minus => return "Minus",
        TokenType::Plus => return "Plus",
        TokenType::PlusPlus => return "PlusPlus",
        TokenType::Divide => return "Divide",
        TokenType::Multiply => return "Multiply",
        TokenType::Equals => return "Equals",
        TokenType::Identifier => return "Identifier",
        TokenType::Return => return "Return",
        TokenType::Break => return "Break",
        TokenType::Continue => return "Continue",
        TokenType::Print => return "Print",
        TokenType::Println => return "Println",
        TokenType::LeftParenthesis => return "LeftParenthesis",
        TokenType::RightParenthesis => return "RightParenthesis",
        TokenType::LeftBrace => return "LeftBrace",
        TokenType::RightBrace => return "RightBrace",
        TokenType::LeftSquareBracket => return "LeftSquareBracket",
        TokenType::RightSquareBracket => return "RightSquareBracket",
        TokenType::Semicolon => return "Semicolon",
        TokenType::True => return "True",
        TokenType::False => return "False",
        TokenType::Comment => return "Comment",
        TokenType::EndComment => return "EndComment",
        TokenType::Comma => return "Comma",
        TokenType::FullStop => return "FullStop",
        TokenType::PlusEquals => return "PlusEquals",
        TokenType::MinusEquals => return "MinusEquals",
        TokenType::MultiplyEquals => return "MultiplyEquals",
        TokenType::DivideEquals => return "DivideEquals",
        TokenType::GreaterThan => return "GreaterThan",
        TokenType::LessThan => return "LessThan",
        TokenType::EqualsEquals => return "EqualsEquals",
        TokenType::GreaterThanEquals => return "GreaterThanEquals",
        TokenType::LessThanEquals => return "LessThanEquals",
        TokenType::VariableInSimpleForLoop => return "VariableInSimpleForLoop",
        TokenType::Defer => return "Defer",
        TokenType::New => return "New",
        TokenType::Delete => return "Delete",
        TokenType::In => return "In",
        TokenType::Const => return "Const",
        TokenType::Modulus => return "Modulus",
        TokenType::ModulusEquals => return "ModulusEquals",
        TokenType::NotEquals => return "NotEquals",
        TokenType::And => return "And",
        TokenType::AndAnd => return "AndAnd",
        TokenType::Or => return "Or",
        TokenType::OrOr => return "OrOr",
        TokenType::IntegerVarType => return "IntegerVarType",
        TokenType::Na => return "NA",
        _ => return "Unknown",
    }
}

pub struct ASTNodeType;
impl ASTNodeType {
    pub const Invalid: i32 = 0;
    pub const Comment: i32 = 1;
    pub const Return: i32 = 2;
    pub const Break: i32 = 3;
    pub const Continue: i32 = 4;
    pub const Print: i32 = 5;
    pub const Println: i32 = 6;
    pub const IntegerLiteral: i32 = 7;
    pub const FloatLiteral: i32 = 8;
    pub const StringLiteral: i32 = 9;
    pub const CharLiteral: i32 = 10;
    pub const BoolLiteral: i32 = 11;
    pub const Minus: i32 = 12;
    pub const Reference: i32 = 13;
    pub const DereferenceAssignment: i32 = 14;
    pub const FunctionBody: i32 = 15;
    pub const ForBody: i32 = 16;
    pub const ElseBody: i32 = 17;
    pub const IfBody: i32 = 18;
    pub const WhileBody: i32 = 19;
    pub const ArrayDeclaration: i32 = 20;
    pub const PointerDeclaration: i32 = 21;
    pub const FunctionDeclaration: i32 = 22;
    pub const Declaration: i32 = 23;
    pub const FunctionCall: i32 = 24;
    pub const ArrayGroup: i32 = 25;
    pub const ArrayElement: i32 = 26;
    pub const ArrayAccess: i32 = 27;
    pub const ArrayIndexReassignment: i32 = 28;
    pub const Array: i32 = 29;
    pub const PrintExpression: i32 = 30;
    pub const BinaryExpression: i32 = 31;
    pub const ReturnExpression: i32 = 32;
    pub const BoolExpression: i32 = 33;
    pub const BoolComparison: i32 = 34;
    pub const VarType: i32 = 35;
    pub const Pointer: i32 = 36;
    pub const ReturnType: i32 = 37;
    pub const Const: i32 = 38;
    pub const Parameter: i32 = 39;
    pub const Parameters: i32 = 40;
    pub const StructVariable: i32 = 41;
    pub const IfStatement: i32 = 42;
    pub const WhileLoop: i32 = 43;
    pub const ForLoop: i32 = 44;
    pub const ForCondition: i32 = 45;
    pub const Else: i32 = 46;
    pub const SwitchStatement: i32 = 47;
    pub const SwitchCondition: i32 = 48;
    pub const SwitchBody: i32 = 49;
    pub const SwitchCase: i32 = 50;
    pub const SwitchDefault: i32 = 51;
    pub const CaseBlock: i32 = 52;
    pub const Identifier: i32 = 53;
    pub const FullStop: i32 = 54;
    pub const Assignment: i32 = 55;
}
pub fn astnodetype_to_string(astnodetype: i32) -> &'static str {
    match astnodetype {
        ASTNodeType::Invalid => "Invalid",
        ASTNodeType::Comment => "Comment",
        ASTNodeType::Return => "Return",
        ASTNodeType::Break => "Break",
        ASTNodeType::Continue => "Continue",
        ASTNodeType::Print => "Print",
        ASTNodeType::Println => "Println",
        ASTNodeType::IntegerLiteral => "IntegerLiteral",
        ASTNodeType::FloatLiteral => "FloatLiteral",
        ASTNodeType::StringLiteral => "StringLiteral",
        ASTNodeType::CharLiteral => "CharLiteral",
        ASTNodeType::BoolLiteral => "BoolLiteral",
        ASTNodeType::Minus => "Minus",
        ASTNodeType::Reference => "Reference",
        ASTNodeType::DereferenceAssignment => "DereferenceAssignment",
        ASTNodeType::FunctionBody => "FunctionBody",
        ASTNodeType::ForBody => "ForBody",
        ASTNodeType::ElseBody => "ElseBody",
        ASTNodeType::IfBody => "IfBody",
        ASTNodeType::WhileBody => "WhileBody",
        ASTNodeType::ArrayDeclaration => "ArrayDeclaration",
        ASTNodeType::PointerDeclaration => "PointerDeclaration",
        ASTNodeType::FunctionDeclaration => "FunctionDeclaration",
        ASTNodeType::Declaration => "Declaration",
        ASTNodeType::FunctionCall => "FunctionCall",
        ASTNodeType::ArrayGroup => "ArrayGroup",
        ASTNodeType::ArrayElement => "ArrayElement",
        ASTNodeType::ArrayAccess => "ArrayAccess",
        ASTNodeType::ArrayIndexReassignment => "ArrayIndexReassignment",
        ASTNodeType::Array => "Array",
        ASTNodeType::PrintExpression => "PrintExpression",
        ASTNodeType::BinaryExpression => "BinaryExpression",
        ASTNodeType::ReturnExpression => "ReturnExpression",
        ASTNodeType::BoolExpression => "BoolExpression",
        ASTNodeType::BoolComparison => "BoolComparison",
        ASTNodeType::VarType => "VarType",
        ASTNodeType::Pointer => "Pointer",
        ASTNodeType::ReturnType => "ReturnType",
        ASTNodeType::Const => "Const",
        ASTNodeType::Parameter => "Parameter",
        ASTNodeType::Parameters => "Parameters",
        ASTNodeType::StructVariable => "StructVariable",
        ASTNodeType::IfStatement => "IfStatement",
        ASTNodeType::WhileLoop => "WhileLoop",
        ASTNodeType::ForLoop => "ForLoop",
        ASTNodeType::ForCondition => "ForCondition",
        ASTNodeType::Else => "Else",
        ASTNodeType::SwitchStatement => "SwitchStatement",
        ASTNodeType::SwitchCondition => "SwitchCondition",
        ASTNodeType::SwitchBody => "SwitchBody",
        ASTNodeType::SwitchCase => "SwitchCase",
        ASTNodeType::SwitchDefault => "SwitchDefault",
        ASTNodeType::CaseBlock => "CaseBlock",
        ASTNodeType::Identifier => "Identifier",
        ASTNodeType::FullStop => "FullStop",
        ASTNodeType::Assignment => "Assignment",
        _ => "Unknown",
    }
}

pub struct LoopResult;
impl LoopResult {
    pub const None: i32 = 0;
    pub const Continue: i32 = 1;
    pub const Break: i32 = 2;
    pub const Return: i32 = 3;
}

